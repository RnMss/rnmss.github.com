---
layout: post
title: 代码节操系列（一）
summary: 序：那些你看不懂的代码
---

> 傻瓜都能写出机器能看懂的代码，聪明人才能写出人能看懂的代码。

<span style="padding-left: 5em">——某人  (这话谁说的我搜不到啊！)</span>

---

## 那些你不懂的东西有多牛

有一些代码，写起来容易，写的人知道是什么意思，但是读的人未必能懂。比如机器语言、汇编语言、或者……
下面这样的代码（想必你一定见过类似的东西）：

<pre class="prettyprint lang-cpp linenums">
#include &lt;stdio.h&gt; 
#define _ i 
#define __ n 
#define ___ _##__##t 
#define ____ scanf 
#define _____ printf 
#define ______ "%d" 
___ main() { 
    ___ _, __; 
    ____(______ ______, &_, &__); 
    _____(______ "\n", _+__); 
    return 0; 
}
</pre>

其实把“`#define`”展开，就变成了这个样子：

<pre class="prettyprint lang-cpp linenums">
#include &lt;stdio.h&gt; 
int main() { 
    int a, b; 
    scanf("%d%d", &a, &b); 
    printf("%d\n", a+b); 
    return 0; 
}
</pre>

啦啦啦~~ 一段你能看懂的代码，稍加修改，就变成了前面那个样子，几乎无法阅读了。

所以永远不要那些你看不懂的代码有什么值得膜拜的地方，有些只是他们写得不够简单易懂而已。

不要觉得那些你不懂的东西有多牛，因为那往往只是叙述者 *捉鸡* 的表达能力，或者故弄玄虚的卖 *节操* 行为~

## 为什么有些代码读不懂

当你代码读不懂，通常会被别人归结为以下几种原因：

* 代码编写者有意不让你看懂，如：
	* 使用了代码混淆器，或者压缩器 （常见于javascript）
	* 故弄玄虚（比如上面这种情况）
* 你缺少读懂此代码的知识储备，如：
	* 你不熟悉这种编程语言或者该程序相关的API
	* 使用了你不知道的数学公式、算法

不过，这两种情况并不是我想讨论的内容 _（路人：“不讨论你说个毛线！”）_ ：现在你是一位经验丰富的 ~~苦B~~ 程序猿，你了解你要读的代码是做神马用的，也知道其大致的思路，甚至还拥有全套的详细设计文档之类的东东……可是你 ~~TMD~~ 就是看不懂！_(气死偶累！)_

假如发生了这种情况，这最有可能是因为什么？

### 编码风格？

所谓风格，很大程度上是从美学的角度讲的。

<pre class="prettyprint lang-cpp linenums">
#include &lt;stdio.h&gt; 
int main() { int a, number_B; scanf("%d%d", &a, 
&number_B); if (a > number_B) { number_B = a - number_B;
} else number_B = number_B - a; printf("%d\n",
a); return 0; }
</pre>

像这样，不缩进，不换行，命名风格不统一的代码应该是最难懂的了吧？

我的回答是两个字：“呵呵。”

大多程序员都受过这样的训练，或者被强制要求统一使用某种风格，况且很少人会跟自己过不去写出上面这样的代码。

（其实这样的问题完全有机械化的解决方法。除了命名风格不能统一以外，缩进，换行，以及大括号的位置，都可以使用代码格式化程序，把缩进神马的弄的漂漂亮亮的，甚至还能自动加上诸如`/* end while (i>=0) */`这样的注释呢。）

### Goto？

> 使用goto的频率与程序员的水平成反比。

<span style="padding-left: 5em">——Dijkstra</span>

**请注意：** 这句话是有时代背景的！因为那个时代机器慢得很，写一句goto省几行代码，也能省几个CPU指令周期。 
_（就像当初存储资源紧缺，为了剩空间用两个十进制数表示年份，结果就千年虫了。）_
现在这个年头，有几个会用goto的啊，不会用goto的人还在说“goto有害论”？

滥用goto的确有害，但是滥用循环就无害了？goto不是罪魁祸首，只是表象。

其实goto可以比循环很好地实现诸如**有限确定状态机**这样的逻辑。（不信你不妨尝试写一个这样的函数：等待键盘按下`Y`或`N`，并返回“真”或“假”，如果按键不是`Y`,`N`中的一个，则重试。看看如果使用各种循环是不是真的比使用goto更清晰。）

### 魔法数字？

像`0`, `1`这样的数字写多了，的确分不清意义了。

可是仅仅靠给数字起个名字就能解决问题么？其实不然：既然有“魔法数字”，那是否也有“魔法类型”，“魔法变量”？
`int`写多了，还能分得清意义么？把`int`替换成`HANDLE`这样的名字就能解决么？`HANDLE`是否也有不同的种类和作用？每一处都进行类型转换，又会使程序变得冗长。

那么到底问题出在哪里呢？

### 代码架构

其实，再好的代码风格都抵不过一个糟糕的架构。

> 一个糟糕的程序架构，就好比你在兲朝办事，经常会被踢皮球，于是你东跑西跑，你不知道接下来要跑多少部门，惟一值得庆幸的是给你办事的人都能厚颜无耻地保持服务态度（代码风格）还都不错。

不妨看下面一团代码：

<pre class="prettyprint lang-cpp linenums">
#include &lt;stdio.h&gt;

int a, b, c;

void input() {
	scanf("%d%d", &a, &b);
}

void calc() {
	for ( ; ; ) {
		a = a % b;
		if (a == 0) {
			c = b;
			break;
		}
		b = b % a;
		if (b == 0) {
			c = a;
			break;
		}
	}
}

void output() {
	printf("%d\n", c);
}

int main() { 
	input();
	calc();
	output(); 
    return 0; 
}
</pre>

这是一段看起来非常规范的代码，似乎还有很良好的可扩展性？
可事实上，这段代码完全没有可复用性！

为什么？

* `calc()`函数放进别的函数里还能用吗？

一旦这个函数移出这个环境，就会因为找不到变量而无法使用。即使封装成库，使用者必须熟知其调用方法，手动给`a`, `b`赋值，并从`c`种读出这个结果。如果程序变得更大，将变得更加难以维护。

* 多线程同时调用了`calc()`函数还能保证结果吗？

显然会冲突嘛，这个就不用解释了……

像这样的代码架构，其实只是将一个很长的程序按照调用的时间顺序，拆成了几个部分，让单个函数变得更短了。而这个年头，最不重要的就是执行的时间顺序了。

<pre class="prettyprint lang-cpp linenums">
#include &lt;stdio.h&gt;

void input(int *a, int *b) {
	scanf("%d%d", &a, &b);
}

int calc(int a, int b) {
	for ( ; ; ) {
		a = a % b;
		if (a == 0) return b;
		b = b % a;
		if (b == 0) return a;
	}
}

void output(int x) {
	printf("%d\n", x);
}

int main() { 
	int a, b, c;
	input(&a, &b);
	c = calc(a, b);
	output(c);
    return 0; 
}
</pre>

如果这样写，代码是不是清晰多了？

## 总结

1. 写代码让人看不懂的人，节操都掉一地。
2. 写有节操代码，合理架构才是王道，风格神马的都是浮云。

欲知后事如何，请听下回分解。