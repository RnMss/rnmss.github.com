---
layout: post
title: 代码节操系列（二）
summary: 读不懂代码的原因
category: 编程
tags:
	- 编程
	- 节操
	- 可维护性

---

> 写有节操的代码攒人品，写没节操的代码损人品。人品损多了，是会追不到妹子的哦~

所谓代码的节操嘛，当然指的是代码除了它实现的功能本身之外的部分，也就是诸如可维护性、可扩展性、可复用性、可读性之类的这些东西啦。

## 代码架构

上回讲到，决定代码节操的，最重要的就是代码的架构了。衡量代码架构的好坏的方法，我认为当然是可复用性（其他的神马都是浮云）。

### 可复用性

所谓可复用性，很大程度指的是代码本身被封装的如何。（别人的代码知道怎么用就好了，至于内部实现你大可不必关心哈哈）不过……

> 好的产品不仅从外面要美，里面看也要美。

好吧……原话我好不到了好吧，总之乔帮主是说过类似的话的……你要是自己拆过 Thinkpad 清灰，再拆过 Macbook，就应该知道差距了。（我这不是黑 Thinkpad，因为以后的帖子你会看到我把微软黑出翔的。）

不要以为你买了台 Macbook 就不会拆开，如果有一天你想换硬盘，你不会满足于买一块USB移动硬盘挂在外面吧？维护代码是不可避免的，因为需求是无止境滴，总有修改代码的时候。

所以好的代码不仅封装后有很好的可复用性，里面每个函数都应该有良好的可复用性。

我们来看看上一次的那段无节操代码：

<pre class="prettyprint lang-cpp linenums">
#include &lt;stdio.h&gt;

int a, b, c;

void input() {
	scanf("%d%d", &a, &b);
}

void calc() {
	for ( ; ; ) {
		a = a % b;
		if (a == 0) {
			c = b;
			break;
		}
		b = b % a;
		if (b == 0) {
			c = a;
			break;
		}
	}
}

void output() {
	printf("%d\n", c);
}

int main() { 
    input();
    calc();
    output(); 
    return 0; 
}
</pre>

这样的代码可复用性就差了，也不需要重复解释了。

### 可读性

除了可复用差以外，这样的代码不容易读，为什么？

首先我们以其中的main函数为例：

<pre class="prettyprint lang-cpp">
int main() { 
    input();
    calc();
    output();
    return 0; 
}
</pre>

你能说出这个函数做了哪几件事吗？

有人会回答：“这一目了然啊：输入，计算，输出。”

那么请问什么程序不是“输入，计算，输出”呢？说了等于没说啊，亲。

那么请看另一段程序：

<pre class="prettyprint lang-cpp">
int main() { 
	int a, b, c;
	input(&a, &b, &c); 
	c = calc(a, b);
	output(c);
    return 0; 
}
</pre>

再问这个函数做了什么事情？

从这段代码可以看出，“它输入了两个数，并输出了一个与这两个数的值有关的数。”这段代码是不是提供了更大的信息量呢？

你可能还会反驳：前者未必需要提供多少信息量，因为这只是一种通用的框架啊。

那么我现在把`calc()`函数的一部分放到`input()`中，有什么区别？

## “代码读不懂”的原理

这样的代码为什么不容易读？

<pre class="prettyprint lang-cpp">
int main() { 
    input();
    calc();
    output(); 
    return 0; 
}
</pre>

我们来回想一下你读这段代码的过程。

你读到`input();`这条语句的时候，你并不知道发生了什么，于是需要翻到上面参看`input()`函数的定义。

<pre class="prettyprint lang-cpp">
void input() {
	scanf("%d%d", &a, &b);
}
</pre>

你知道`scanf(fmt, ...)`这个函数的作用，但是你看到了`a`, `b`这样两个变量，你发现它们是全局变量，然后你翻到顶部，发现了它们的定义：

<pre class="prettyprint lang-cpp">
int a, b, c;
</pre>

你发现的确有这样两个全局变量，不过你又发现了其他的变量`c`——这个变量还不知道是做什么用的，暂时放着不管。

然后你发现`input()`函数读完了，接下来该做什么了？如果这个函数很长，你还记得吗？

现在你去读`calc()`函数，发现`a`, `b`, `c`,三个变量都接受过赋值，你已经搞不清发生了什么了。

最后你去读`output()`函数，发现最终只输出了`c`，于是你恍然大悟，去把`calc()`重新读了一次。

然后整个结构你已经忘了，你又去把`main()`函数重新读一遍。

也许你记忆力很好，上面的事情不会都发生，放心，比这长一千倍的代码等着你呢，亲。

相比之下，另一种实现读起来就简单的多：

<pre class="prettyprint lang-cpp">
int calc(int a, int b) {
	for ( ; ; ) {
		a = a % b;
		if (a == 0) return b;
		b = b % a;
		if (b == 0) return a;
	}
}
</pre>

因为每个函数在你读之前就能明白它大概是做什么的，而且每一条语句所依赖的变量都能在附近找到定义。

### 生活中的例子

如果你觉得这种解释不好理解，那么我给你讲一个故事。

过年了，你家吃饺子，你现在要做的是在锅里放上饺子。于是你要做的是，买材料，包饺子，放进锅；但是你自己不会包饺子，自己家里也没有食材。

#### 方案一

* 你做的事
	* 从小明那里买来肉馅和面皮。
	* 将肉馅和面皮交给小红并等待包好的饺子。
	* 将包好的饺子交给小强。
* 小明做的事
	* 将肉馅和面皮交给你
* 小红做的事
	* 用收到肉馅和面皮来包饺子，并将包好的饺子交给你
* 小强做的事
	* 将收到的包好的饺子放进锅中


#### 方案二

* 你做的事：
	* 把钱交给小明，要求小明说执行计划第一步：获取食材。
	* 要求小红执行计划第二步：制作。
	* 要求小强执行计划第三步：放进锅。
* 小明做的事：
	* 将肉馅和面皮分别放在地点A和地点B。
* 小红做的事：
	* 分别从地点A和地点B获取肉馅和面皮
	* 用获取到的肉馅和面皮包饺子
	* 将包好的饺子放到地点C
* 小强做的事：
	* 从地点C取来包好的饺子，并将它们放进锅中

你觉得这俩方案哪个更靠谱？哪个更容易理解？哪个更不容易出差错？如果出了差错哪个更容易排查？

如果地点A、B、C任意一项变动了，你必须通知两个人改变计划。

在任务执行过程中如果出现问题，你要么必须了解其他人的工作过程，要么必须等到整个任务结束了才能知道。

## 总结

1. 代码可复用性不能只体现在封装伤，内部的每个函数都应该有良好的可复用性。
2. 代码的可读性体现在每个函数提供的信息量是否适量。
3. 代码的可读性取决于阅读代码对记忆力或辅助工具的要求度是否更低，即代码中依赖的符号定义的密集程度。
4. 代码的依赖关系越简单，越容易读，可复用性越好。

欲知后事如何，请听下回分解。